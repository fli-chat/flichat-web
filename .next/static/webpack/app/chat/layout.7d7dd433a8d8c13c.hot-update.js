"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/layout",{

/***/ "(app-pages-browser)/./src/apis/axios.ts":
/*!***************************!*\
  !*** ./src/apis/axios.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: () => (/* binding */ api),\n/* harmony export */   chatApi: () => (/* binding */ chatApi)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _utils_cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cookie */ \"(app-pages-browser)/./src/utils/cookie.ts\");\n/* harmony import */ var _auth_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./auth.api */ \"(app-pages-browser)/./src/apis/auth.api.ts\");\n/* eslint-disable @typescript-eslint/no-explicit-any */ \n\n\nconst api = axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create({\n    baseURL: \"https://api.flichat.co.kr\",\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\nconst chatApi = axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create({\n    baseURL: \"https://chat.flichat.co.kr\",\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\nconst withAuthHeader = (config, token)=>{\n    var _config_headers;\n    config.headers = (_config_headers = config.headers) !== null && _config_headers !== void 0 ? _config_headers : {};\n    config.headers.Authorization = \"Bearer \".concat(token);\n    return config;\n};\n// ===== Request interceptors =====\nconst attachAccessToken = (config)=>{\n    // ✅ 클라이언트에서만 실행\n    if (true) {\n        const token = localStorage.getItem(\"accessToken\");\n        if (token) withAuthHeader(config, token);\n    }\n    return config;\n};\napi.interceptors.request.use(attachAccessToken, Promise.reject);\nchatApi.interceptors.request.use(attachAccessToken, Promise.reject);\n// ===== Refresh queue state =====\nlet isRefreshing = false;\nlet failedQueue = [];\nconst processQueue = function(error) {\n    let token = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    failedQueue.forEach((param)=>{\n        let { resolve, reject } = param;\n        if (error || !token) reject(error || new Error(\"No refreshed token\"));\n        else resolve(token);\n    });\n    failedQueue = [];\n};\n// const redirectToLogin = async () => {\n//   if (window.location.pathname !== \"/\") {\n//     window.location.replace(\"/chat/login\");\n//   }\n//   await useAuth.getState().setAuthStatus(AuthStatus.unauthorized);\n// };\nconst makeResponseInterceptor = (client)=>async (response)=>{\n        return response;\n    };\n/**\n * 공통 에러 처리(401 → refresh → 재시도)\n * - 현재 인스턴스(client)로 재시도\n */ const makeErrorInterceptor = (client)=>async (error)=>{\n        const originalConfig = error.config || {};\n        // 응답 자체가 없으면(네트워크 등) 그대로 던짐\n        if (!error.response) {\n            return Promise.reject(error);\n        }\n        const status = error.response.status;\n        // refresh 호출이 401이면 즉시 로그아웃/리다이렉트\n        // if (originalConfig.url?.includes(\"/refresh\") && status === 401) {\n        //   await redirectToLogin();\n        //   return Promise.reject(error);\n        // }\n        // 401 처리\n        if (status === 401 && !originalConfig._retry) {\n            // ✅ 클라이언트에서만 refresh 로직 실행\n            if (false) {}\n            if (isRefreshing) {\n                // 새 토큰이 나올 때까지 대기\n                return new Promise((resolve, reject)=>{\n                    failedQueue.push({\n                        resolve: (token)=>{\n                            try {\n                                originalConfig.headers = {\n                                    ...originalConfig.headers\n                                };\n                                withAuthHeader(originalConfig, token);\n                                resolve(client.request(originalConfig));\n                            } catch (e) {\n                                reject(e);\n                            }\n                        },\n                        reject\n                    });\n                });\n            }\n            originalConfig._retry = true;\n            isRefreshing = true;\n            try {\n                const storedAccessToken = localStorage.getItem(\"accessToken\");\n                const storedRefreshToken = (0,_utils_cookie__WEBPACK_IMPORTED_MODULE_0__.getCookie)(\"refreshToken\");\n                if (!storedAccessToken || !storedRefreshToken) {\n                    throw new Error(\"토큰이 없습니다.\");\n                }\n                const { accessToken, refreshToken } = await _auth_api__WEBPACK_IMPORTED_MODULE_1__.AuthApi.refreshToken(storedAccessToken, storedRefreshToken);\n                if (!accessToken || !refreshToken) {\n                    throw new Error(\"토큰 갱신 실패\");\n                }\n                // 새 토큰 저장\n                localStorage.setItem(\"accessToken\", accessToken);\n                (0,_utils_cookie__WEBPACK_IMPORTED_MODULE_0__.setCookie)(\"refreshToken\", refreshToken, {\n                    path: \"/\",\n                    // 운영 환경에서는 보안 옵션 권장\n                    secure: true,\n                    sameSite: \"Lax\"\n                });\n                // 대기 중이던 요청들 처리\n                processQueue(null, accessToken);\n                // 현재 실패했던 이 요청에도 새 토큰 주입해서 재시도\n                withAuthHeader(originalConfig, accessToken);\n                return client(originalConfig);\n            } catch (refreshErr) {\n                // 대기열 전부 실패 처리\n                processQueue(refreshErr, null);\n                // await redirectToLogin();\n                return Promise.reject(refreshErr);\n            } finally{\n                isRefreshing = false;\n            }\n        }\n        // 기타 에러는 그대로\n        return Promise.reject(error);\n    };\n// ===== Response interceptors 등록 =====\napi.interceptors.response.use(makeResponseInterceptor(api), makeErrorInterceptor(api));\nchatApi.interceptors.response.use(makeResponseInterceptor(chatApi), makeErrorInterceptor(chatApi));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cyI6WyIvVXNlcnMvbGlmZWRpdmVyZ2VuY2UxL0Rlc2t0b3AvZmxpY2hhdC13ZWIvc3JjL2FwaXMvYXhpb3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuaW1wb3J0IGF4aW9zLCB7IEF4aW9zRXJyb3IsIHR5cGUgSW50ZXJuYWxBeGlvc1JlcXVlc3RDb25maWcgfSBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCB7IGdldENvb2tpZSwgc2V0Q29va2llIH0gZnJvbSBcIi4uL3V0aWxzL2Nvb2tpZVwiO1xuaW1wb3J0IHsgQXV0aEFwaSB9IGZyb20gXCIuL2F1dGguYXBpXCI7XG5cbnR5cGUgUmV0cmlhYmxlQ29uZmlnID0gSW50ZXJuYWxBeGlvc1JlcXVlc3RDb25maWcgJiB7IF9yZXRyeT86IGJvb2xlYW4gfTtcblxuZXhwb3J0IGNvbnN0IGFwaSA9IGF4aW9zLmNyZWF0ZSh7XG4gIGJhc2VVUkw6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwsXG4gIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbn0pO1xuXG5leHBvcnQgY29uc3QgY2hhdEFwaSA9IGF4aW9zLmNyZWF0ZSh7XG4gIGJhc2VVUkw6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NIQVRfQVBJX1VSTCxcbiAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxufSk7XG5cbmNvbnN0IHdpdGhBdXRoSGVhZGVyID0gKGNvbmZpZzogSW50ZXJuYWxBeGlvc1JlcXVlc3RDb25maWcsIHRva2VuOiBzdHJpbmcpID0+IHtcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyA/PyB7fTtcbiAgKGNvbmZpZy5oZWFkZXJzIGFzIGFueSkuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICByZXR1cm4gY29uZmlnO1xufTtcblxuLy8gPT09PT0gUmVxdWVzdCBpbnRlcmNlcHRvcnMgPT09PT1cbmNvbnN0IGF0dGFjaEFjY2Vzc1Rva2VuID0gKGNvbmZpZzogSW50ZXJuYWxBeGlvc1JlcXVlc3RDb25maWcpID0+IHtcbiAgLy8g4pyFIO2BtOudvOydtOyWuO2KuOyXkOyEnOunjCDsi6TtlolcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImFjY2Vzc1Rva2VuXCIpO1xuICAgIGlmICh0b2tlbikgd2l0aEF1dGhIZWFkZXIoY29uZmlnLCB0b2tlbik7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbmFwaS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoYXR0YWNoQWNjZXNzVG9rZW4sIFByb21pc2UucmVqZWN0KTtcbmNoYXRBcGkuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKGF0dGFjaEFjY2Vzc1Rva2VuLCBQcm9taXNlLnJlamVjdCk7XG5cbi8vID09PT09IFJlZnJlc2ggcXVldWUgc3RhdGUgPT09PT1cbmxldCBpc1JlZnJlc2hpbmcgPSBmYWxzZTtcbmxldCBmYWlsZWRRdWV1ZTogQXJyYXk8eyByZXNvbHZlOiAodDogc3RyaW5nKSA9PiB2b2lkOyByZWplY3Q6IChlOiBhbnkpID0+IHZvaWQgfT4gPSBbXTtcblxuY29uc3QgcHJvY2Vzc1F1ZXVlID0gKGVycm9yOiBhbnksIHRva2VuOiBzdHJpbmcgfCBudWxsID0gbnVsbCkgPT4ge1xuICBmYWlsZWRRdWV1ZS5mb3JFYWNoKCh7IHJlc29sdmUsIHJlamVjdCB9KSA9PiB7XG4gICAgaWYgKGVycm9yIHx8ICF0b2tlbikgcmVqZWN0KGVycm9yIHx8IG5ldyBFcnJvcihcIk5vIHJlZnJlc2hlZCB0b2tlblwiKSk7XG4gICAgZWxzZSByZXNvbHZlKHRva2VuKTtcbiAgfSk7XG4gIGZhaWxlZFF1ZXVlID0gW107XG59O1xuXG4vLyBjb25zdCByZWRpcmVjdFRvTG9naW4gPSBhc3luYyAoKSA9PiB7XG4vLyAgIGlmICh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgIT09IFwiL1wiKSB7XG4vLyAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoXCIvY2hhdC9sb2dpblwiKTtcbi8vICAgfVxuLy8gICBhd2FpdCB1c2VBdXRoLmdldFN0YXRlKCkuc2V0QXV0aFN0YXR1cyhBdXRoU3RhdHVzLnVuYXV0aG9yaXplZCk7XG4vLyB9O1xuXG5jb25zdCBtYWtlUmVzcG9uc2VJbnRlcmNlcHRvciA9XG4gIChjbGllbnQ6IHR5cGVvZiBhcGkpID0+XG4gIGFzeW5jIChyZXNwb25zZTogYW55KSA9PiB7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xuXG4vKipcbiAqIOqzte2GtSDsl5Drn6wg7LKY66asKDQwMSDihpIgcmVmcmVzaCDihpIg7J6s7Iuc64+EKVxuICogLSDtmITsnqwg7J247Iqk7YS07IqkKGNsaWVudCnroZwg7J6s7Iuc64+EXG4gKi9cbmNvbnN0IG1ha2VFcnJvckludGVyY2VwdG9yID1cbiAgKGNsaWVudDogdHlwZW9mIGFwaSkgPT5cbiAgYXN5bmMgKGVycm9yOiBBeGlvc0Vycm9yKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxDb25maWcgPSAoZXJyb3IuY29uZmlnIHx8IHt9KSBhcyBSZXRyaWFibGVDb25maWc7XG5cbiAgICAvLyDsnZHri7Ug7J6Q7LK06rCAIOyXhuycvOuptCjrhKTtirjsm4ztgawg65OxKSDqt7jrjIDroZwg642Y7KeQXG4gICAgaWYgKCFlcnJvci5yZXNwb25zZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0dXMgPSBlcnJvci5yZXNwb25zZS5zdGF0dXM7XG5cbiAgICAvLyByZWZyZXNoIO2YuOy2nOydtCA0MDHsnbTrqbQg7KaJ7IucIOuhnOq3uOyVhOybgy/rpqzri6TsnbTroIntirhcbiAgICAvLyBpZiAob3JpZ2luYWxDb25maWcudXJsPy5pbmNsdWRlcyhcIi9yZWZyZXNoXCIpICYmIHN0YXR1cyA9PT0gNDAxKSB7XG4gICAgLy8gICBhd2FpdCByZWRpcmVjdFRvTG9naW4oKTtcbiAgICAvLyAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgLy8gfVxuXG4gICAgLy8gNDAxIOyymOumrFxuICAgIGlmIChzdGF0dXMgPT09IDQwMSAmJiAhb3JpZ2luYWxDb25maWcuX3JldHJ5KSB7XG4gICAgICAvLyDinIUg7YG065287J207Ja47Yq47JeQ7ISc66eMIHJlZnJlc2gg66Gc7KeBIOyLpO2WiVxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1JlZnJlc2hpbmcpIHtcbiAgICAgICAgLy8g7IOIIO2GoO2BsOydtCDrgpjsmKwg65WM6rmM7KeAIOuMgOq4sFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGZhaWxlZFF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgcmVzb2x2ZTogKHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxDb25maWcuaGVhZGVycyA9IHsgLi4uKG9yaWdpbmFsQ29uZmlnLmhlYWRlcnMgYXMgYW55KSB9O1xuICAgICAgICAgICAgICAgICAgd2l0aEF1dGhIZWFkZXIob3JpZ2luYWxDb25maWcsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoY2xpZW50LnJlcXVlc3Qob3JpZ2luYWxDb25maWcpKTsgXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5hbENvbmZpZy5fcmV0cnkgPSB0cnVlO1xuICAgICAgaXNSZWZyZXNoaW5nID0gdHJ1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RvcmVkQWNjZXNzVG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImFjY2Vzc1Rva2VuXCIpO1xuICAgICAgICBjb25zdCBzdG9yZWRSZWZyZXNoVG9rZW4gPSBnZXRDb29raWUoXCJyZWZyZXNoVG9rZW5cIik7XG5cbiAgICAgICAgaWYgKCFzdG9yZWRBY2Nlc3NUb2tlbiB8fCAhc3RvcmVkUmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwi7Yag7YGw7J20IOyXhuyKteuLiOuLpC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4gfSA9IGF3YWl0IEF1dGhBcGkucmVmcmVzaFRva2VuKFxuICAgICAgICAgIHN0b3JlZEFjY2Vzc1Rva2VuLFxuICAgICAgICAgIHN0b3JlZFJlZnJlc2hUb2tlblxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghYWNjZXNzVG9rZW4gfHwgIXJlZnJlc2hUb2tlbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIu2GoO2BsCDqsLHsi6Ag7Iuk7YyoXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g7IOIIO2GoO2BsCDsoIDsnqVcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJhY2Nlc3NUb2tlblwiLCBhY2Nlc3NUb2tlbik7XG4gICAgICAgIHNldENvb2tpZShcInJlZnJlc2hUb2tlblwiLCByZWZyZXNoVG9rZW4sIHtcbiAgICAgICAgICBwYXRoOiBcIi9cIixcbiAgICAgICAgICAvLyDsmrTsmIEg7ZmY6rK97JeQ7ISc64qUIOuztOyViCDsmLXshZgg6raM7J6lXG4gICAgICAgICAgc2VjdXJlOiB0cnVlLFxuICAgICAgICAgIHNhbWVTaXRlOiBcIkxheFwiLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyDrjIDquLAg7KSR7J20642YIOyalOyyreuTpCDsspjrpqxcbiAgICAgICAgcHJvY2Vzc1F1ZXVlKG51bGwsIGFjY2Vzc1Rva2VuKTtcblxuICAgICAgICAvLyDtmITsnqwg7Iuk7Yyo7ZaI642YIOydtCDsmpTssq3sl5Drj4Qg7IOIIO2GoO2BsCDso7zsnoXtlbTshJwg7J6s7Iuc64+EXG4gICAgICAgIHdpdGhBdXRoSGVhZGVyKG9yaWdpbmFsQ29uZmlnLCBhY2Nlc3NUb2tlbik7XG4gICAgICAgIHJldHVybiBjbGllbnQob3JpZ2luYWxDb25maWcpO1xuICAgICAgfSBjYXRjaCAocmVmcmVzaEVycikge1xuICAgICAgICAvLyDrjIDquLDsl7Qg7KCE67aAIOyLpO2MqCDsspjrpqxcbiAgICAgICAgcHJvY2Vzc1F1ZXVlKHJlZnJlc2hFcnIsIG51bGwpO1xuICAgICAgICAvLyBhd2FpdCByZWRpcmVjdFRvTG9naW4oKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlZnJlc2hFcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaXNSZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8g6riw7YOAIOyXkOufrOuKlCDqt7jrjIDroZxcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9O1xuXG4vLyA9PT09PSBSZXNwb25zZSBpbnRlcmNlcHRvcnMg65Ox66GdID09PT09XG5hcGkuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShtYWtlUmVzcG9uc2VJbnRlcmNlcHRvcihhcGkpLCBtYWtlRXJyb3JJbnRlcmNlcHRvcihhcGkpKTtcbmNoYXRBcGkuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShtYWtlUmVzcG9uc2VJbnRlcmNlcHRvcihjaGF0QXBpKSwgbWFrZUVycm9ySW50ZXJjZXB0b3IoY2hhdEFwaSkpOyJdLCJuYW1lcyI6WyJheGlvcyIsImdldENvb2tpZSIsInNldENvb2tpZSIsIkF1dGhBcGkiLCJhcGkiLCJjcmVhdGUiLCJiYXNlVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJoZWFkZXJzIiwiY2hhdEFwaSIsIk5FWFRfUFVCTElDX0NIQVRfQVBJX1VSTCIsIndpdGhBdXRoSGVhZGVyIiwiY29uZmlnIiwidG9rZW4iLCJBdXRob3JpemF0aW9uIiwiYXR0YWNoQWNjZXNzVG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInVzZSIsIlByb21pc2UiLCJyZWplY3QiLCJpc1JlZnJlc2hpbmciLCJmYWlsZWRRdWV1ZSIsInByb2Nlc3NRdWV1ZSIsImVycm9yIiwiZm9yRWFjaCIsInJlc29sdmUiLCJFcnJvciIsIm1ha2VSZXNwb25zZUludGVyY2VwdG9yIiwiY2xpZW50IiwicmVzcG9uc2UiLCJtYWtlRXJyb3JJbnRlcmNlcHRvciIsIm9yaWdpbmFsQ29uZmlnIiwic3RhdHVzIiwiX3JldHJ5IiwicHVzaCIsImUiLCJzdG9yZWRBY2Nlc3NUb2tlbiIsInN0b3JlZFJlZnJlc2hUb2tlbiIsImFjY2Vzc1Rva2VuIiwicmVmcmVzaFRva2VuIiwic2V0SXRlbSIsInBhdGgiLCJzZWN1cmUiLCJzYW1lU2l0ZSIsInJlZnJlc2hFcnIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/apis/axios.ts\n"));

/***/ })

});